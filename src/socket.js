/**
 * For handling socket connection
 * Each user will have the option of either entering a new room or joining a room
 * Once in a room, the user will have the option of inputing a secret or creating a new secret
 * When a user creates a room, each room will have options, max entries, number of keys required
 */

const http = require('http')
const uniqid = require('uniqid')
const app = require('./app')
const shamir = require('./shamir')
const server = http.createServer(app)

const io = require('socket.io')(server)
const socketROOMS = {}   //  where the rooms will be stored

const userROOMS = {}   // where the rooms the user is in will be stored

const createRoomUpdate = (args) => {
    const forge = args.forge.map(item => item["id"])
    const create = args.create.map(item => item["id"])

    return {
        id: args.id,
        users: args.users,
        mkeys: args.mkeys,
        cur_users: args.cur_users,
        forge,
        create,
    }
}

// function to create a secret and share key share
const scatterSecretForRoom = (roomID) => {
    const users = socketROOMS[roomID].cur_users
    const secrets = socketROOMS[roomID].create
    const room = socketROOMS[roomID]
    /**
     * take a random letter from anyone and parse a secret
     */
    let shamirSec = ''
    for (let i = 0; i < 8; i++) {
        let rU = Math.floor(Math.random() * users.length)
        let secret = secrets[rU]["secret"]
        let rM = Math.floor(Math.random() * secret.length)
        shamirSec += secret[rM]     // taking a random letter from a random secret
    }

    console.log(`The secret generated by room ${roomID} is ${shamirSec}`)
    const encShamir = new shamir.CreateShamirSecret(shamirSec, room.mkeys, room.users)
    const keys = encShamir.getKeyShares()
    console.log(keys)

    // sending keys to one user only
    for (let i = 0; i < users.length; i++) {
        io.to(users[i]).emit('secret:key_share', {
            a: keys[i][0].toString(),
            b: keys[i][1].toString(),
            p: keys[i][2].toString()
        })
    }
}

const forgeSecretForRoom = (roomID) => {
    const shares = socketROOMS[roomID].forge

    const usersToSend = []      // only sending it to users that sent in their key share
    const shamirKeys = []

    for (let share of shares) {
        usersToSend.push(share.id)
        shamirKeys.push(share.share)
    }

    const decShamir = new shamir.DecodeShamirSecret(shamirKeys)
    const secret = decShamir.getSecret()

    io.to(socketROOMS[roomID].creator_id).emit('secret:forged_secret', secret)

}

io.on('connection', (socket) => {
    console.log(`new socket connection ${socket.id} -- ${Date()}`)

    socket.on('disconnect', () => {
        /**
         * disconnect socket from room, once room has no users, destroy the room
         */
        const roomID = userROOMS[socket.id]

        if (roomID == undefined) {
            return
        }
        delete userROOMS[socket.id]

        const room = socketROOMS[roomID]
        // updating the room information
        room.cur_users = room.cur_users.filter(item => item != socket.id)
        room.forge = room.forge.filter(item => item.id != socket.id)
        room.create = room.create.filter(item => item.id != socket.id)

        if (room.cur_users.length == 0) {
            delete socketROOMS[roomID]
            console.log(`deleted room ${roomID} -- ${Date()}`)
        } else {
            io.to(roomID).emit('client:room_update', createRoomUpdate(room))
        }

        console.log(`socket has disconnected ${socket.id} -- ${Date()}`)
    })

    socket.on('client:new_room', args => {
        const new_roomID = uniqid()
        socketROOMS[new_roomID] = {
            id: new_roomID,
            creator_id: socket.id,
            users: parseInt(args.users),
            mkeys: parseInt(args.mkeys),
            cur_users: [socket.id],
            forge: [],
            create: []
        }
        console.log(`new room ${new_roomID} created -- ${JSON.stringify(socketROOMS[new_roomID])} -- ${Date()}`)

        socket.join(new_roomID)
        userROOMS[socket.id] = new_roomID    // storing user room info

        const room_info = createRoomUpdate(socketROOMS[new_roomID])
        io.to(new_roomID).emit('client:room_update', room_info)
    })

    socket.on('client:join_room', roomID => {
        const room = socketROOMS[roomID]
        console.log(room)
        if ((room == undefined) || !(room.cur_users.length < room.users)) {
            console.log(`${socket.id} could not join room ${roomID}`)
        } else {
            socket.join(roomID)
            room.cur_users.push(socket.id)
            userROOMS[socket.id] = roomID

            const room_info = createRoomUpdate(room)
            io.to(roomID).emit('client:room_update', room_info)

        }
    })

    // too create a secret, and key shares
    socket.on('secret:create', args => {
        const room = socketROOMS[args.id]

        room.create.push({
            id: socket.id,
            secret: args.secret
        })
        io.to(args.id).emit('client:room_update', createRoomUpdate(room))
        console.log(`==Room below received a secret ${Date()} ==`)
        console.log(room)
        console.log(`==Room above received a secret ${Date()} ==`)

        // checking if all users send their secrets
        if (room.create.length == room.users) {
            console.log(room.create)
            scatterSecretForRoom(room.id)
        }

    })


    // too forge a secret
    socket.on('secret:forge', args => {
        const room = socketROOMS[args.id]
        room.forge.push({
            id: socket.id,
            share: [BigInt(args.a), BigInt(args.b), BigInt(args.p)],
        })
        io.to(args.id).emit('client:room_update', createRoomUpdate(room))

        console.log("=== room below received a key share ===")
        console.log(`=== room ${room.id} -- ${Date()}===`)
        console.log("=== room above received a key share ===")

        // code to check if minimum users have inputed the secret to forge and then send out
        if (room.mkeys == room.forge.length) {
            forgeSecretForRoom(room.id)
        }
    })
})




module.exports = server;